#include "wled.h"
#include <esp_now.h>
#include "esp_wifi.h"
#include <RunningMedian.h>

//1: 94:B5:55:F9:ED:80
//2: 94:B5:55:F9:F6:00
//#define ESP1

#ifndef ESP1
#define ESP2
#endif

//#define ESPMini
//mini: 94:B5:55:F9:F6:00
//esp32: F0:08:D1:D1:A6:64

// REPLACE WITH YOUR RECEIVER MAC Address
#ifndef ESPMini
uint8_t broadcastAddress[] = { 0x94, 0xB5, 0x55, 0xF9, 0xF6, 0x00 };  //1 mini: 94:B5:55:F9:F6:00
#else
uint8_t broadcastAddress[] = { 0xF0, 0x08, 0xD1, 0xD1, 0xA6, 0x64 };  //2 //esp32: F0:08:D1:D1:A6:64
#endif

noDelay LEDtime(500);   //Creats a noDelay varible set to 500ms
noDelay sendTime(100);  //Creats a noDelay varible set to 1000ms
int LEDpin = 2;
//int led2State = LOW;

// Structure example to send data
// Must match the receiver structure
typedef struct struct_message {
  char a[32];
  int b;
  float c;
  bool d;
} struct_message;

// Create a struct_message called myData
struct_message myDataOut;
struct_message myDataIn;

// callback function that will be executed when data is received
void OnDataRecv(const uint8_t *mac, const uint8_t *incomingData, int len) {
  memcpy(&myDataIn, incomingData, sizeof(myDataIn));
  Serial.print("Bytes received: ");
  Serial.println(len);
  Serial.print("Char: ");
  Serial.println(myDataIn.a);
  Serial.print("Int: ");
  Serial.println(myDataIn.b);
  Serial.print("Float: ");
  Serial.println(myDataIn.c);
  Serial.print("Bool: ");
  Serial.println(myDataIn.d);
  Serial.println();
  if (myDataIn.d == 0) {
    digitalWrite(2, HIGH);
  } else {
    digitalWrite(2, LOW);
  }
}

esp_now_peer_info_t peerInfo;

// callback when data is sent
void OnDataSent(const uint8_t *mac_addr, esp_now_send_status_t status) {
  Serial.print("\r\nLast Packet Send Status:\t");
  Serial.println(status == ESP_NOW_SEND_SUCCESS ? "Delivery Success" : "Delivery Fail");
}

#pragma region variables
bool autoStopEnabled = 1;
bool enableStatusLED = 1;

const int statusLedOnTime = 1000;
const int stallLedOnTime = 1000;
const int minDelayBetweenStalls = 750;
const int inputReadInterval = 5;

// percentage factor for position of stall at stall change signal (1 = perfectly aligned, .5 = in between stalls)
const int stallPosAtStallChange = .65;

// input pin assignments
const byte stallSensorPin = 4;
const byte bypassSwitchPin = 4;
const byte cowFWDsafetySensorPin = 5;

// led pin assignments
const byte autoStopEnabledLedPin = 16;
const byte stallOKLedPin = 16;
const byte stallEmptyLedPin = 14;
const byte cowFWDsafetyLedPin = 12;

// relay pin assignments
const byte parlorPauseRelayPin = 0;
const byte waterRelayPin = 0;

// LED states
bool autoLedState = 0;
bool stallOKLedState = 0;
bool stallEmptyLedState = 0;
bool cowFWDSafetyLedState = 0;
bool statusLEDState = 0;

// relay states
bool parlorStopRelayState = 0;
bool waterRelayState = 0;

// millis() time of last...
long lastStallChange = 0;
long lastLEDBlink = 0;
long lastStatusLEDBlink = 0;
long lastInputRead = 0;

// parlor vars
bool stallChange = 0;
bool IDChange = 0;
float parlorSpeed = 0;
bool stallEmpty = 0;
bool cowFWDSaftey = 0;

// misc
bool speedMeasured = 0;
long timeToStallCenterPos = 0;

#pragma endregion

// array to calculate running median
RunningMedian speedSamples = RunningMedian(5);

// // espNOW data
// typedef struct struct_message
// {

//   // 1 = stall change
//   // 2 = ID change
//   int type;
//   float speed;
// } struct_message;

// // Create a struct_message called myData
// struct_message stallData;

// // callback function that will be executed when data is received
// void OnDataRecv(const uint8_t *mac, const uint8_t *incomingData, int len)
// {
//   memcpy(&stallData, incomingData, sizeof(stallData));
//   Serial.println(stallData.type);
//   Serial.println(stallData.speed);

//   // 1 = stall change
//   // 2 = ID change
//   if (stallData.type == 1)
//   {
//     stallChange = 1;
//     speedMeasured = 0;
//   }
//   else
//   {
//     IDChange = 1;
//   }
//   // parlorSpeed = stallData.speed;
// }

enum Relays
{
  parlor = 1,
  water = 2,
};

void setRelay(Relays relay, bool state)
{
  if (relay == parlor)
  {
    if (state == 1 && parlorStopRelayState == 0)
    {
      digitalWrite(parlorPauseRelayPin, HIGH);
      parlorStopRelayState = 1;
    }
    else if (state == 0 && parlorStopRelayState == 1)
    {
      digitalWrite(parlorPauseRelayPin, LOW);
      parlorStopRelayState = 0;
    }
  }
  else if (relay == water)
  {
    if (state == 1 && waterRelayState == 0)
    {
      digitalWrite(waterRelayPin, HIGH);
      waterRelayState = 1;
    }
    else if (state == 0 && waterRelayState == 1)
    {
      digitalWrite(waterRelayPin, LOW);
      waterRelayState = 0;
    }
  }
}

enum LEDs
{
  autoStop = 0,
  emptyStall = 1,
  stallOK = 2,
  cowFWD = 3,
  status = 4,
};

void setLED(LEDs led, bool state)
{
  if (led == status)
  {
    if (state == 1 && statusLEDState == 0)
    {
      digitalWrite(2, HIGH);
      statusLEDState = 1;
    }
    else if (state == 0 && statusLEDState == 1)
    {
      digitalWrite(2, LOW);
      statusLEDState = 0;
    }
  }

  else if (led == autoStop)
  {
    if (state == 1 && autoLedState == 0)
    {
      digitalWrite(autoStopEnabledLedPin, HIGH);
      autoLedState = 1;
    }
    else if (state == 0 && autoLedState == 1)
    {
      digitalWrite(autoStopEnabledLedPin, LOW);
      autoLedState = 0;
    }
  }

  else if (led == emptyStall)
  {
    if (state == 1 && stallEmptyLedState == 0)
    {
      digitalWrite(stallEmptyLedPin, HIGH);
      stallEmptyLedState = 1;
    }
    else if (state == 0 && stallEmptyLedState == 1)
    {
      digitalWrite(stallEmptyLedPin, LOW);
      stallEmptyLedState = 0;
    }
  }

  else if (led == stallOK)
  {
    if (state == 1 && stallOKLedState == 0)
    {
      digitalWrite(stallOKLedPin, HIGH);
      stallOKLedState = 1;
    }
    else if (state == 0 && stallOKLedState == 1)
    {
      digitalWrite(stallOKLedPin, LOW);
      stallOKLedState = 0;
    }
  }
  else if (led == cowFWD)
  {
    if (state == 1 && cowFWDSafetyLedState == 0)
    {
      digitalWrite(cowFWDsafetyLedPin, HIGH);
      cowFWDSafetyLedState = 1;
    }
    else if (state == 0 && cowFWDSafetyLedState == 1)
    {
      digitalWrite(cowFWDsafetyLedPin, LOW);
      cowFWDSafetyLedState = 0;
    }
  }
}

// round float to x decimal places
float round_to_dp(float in_value, int decimal_place)
{
  float multiplier = powf(10.0f, decimal_place);
  in_value = roundf(in_value * multiplier) / multiplier;
  return in_value;
}

// calculate the median speed from millis()
void getMedianSpeed()
{
  float x = round_to_dp((millis() - lastStallChange) / 1000, 2);
  lastStallChange = millis();
  speedSamples.add(x);

  parlorSpeed = speedSamples.getMedian();
  timeToStallCenterPos = (parlorSpeed * 1000) * (1 - stallPosAtStallChange);
  speedMeasured = 1;
}
// gets called once at boot. Do all initialization that doesn't depend on network here
void userSetup()
{
 // initialize inputs
  pinMode(stallSensorPin, INPUT);
  pinMode(bypassSwitchPin, INPUT);
  pinMode(cowFWDsafetySensorPin, INPUT);

  // initialize LED outputs
  pinMode(autoStopEnabledLedPin, OUTPUT);
  pinMode(stallOKLedPin, OUTPUT);
  pinMode(2, OUTPUT);
  pinMode(stallEmptyLedPin, OUTPUT);
  pinMode(cowFWDsafetyLedPin, OUTPUT);

  // initialize relay pin outputs
  pinMode(parlorPauseRelayPin, OUTPUT);
  pinMode(waterRelayPin, OUTPUT);

  // initial setting
  digitalWrite(parlorPauseRelayPin, LOW);
  digitalWrite(waterRelayPin, LOW);
  digitalWrite(2, LOW);
}

// gets called every time WiFi is (re-)connected. Initialize own network interfaces here
void userConnected()
{
if (esp_now_init() != ESP_OK) {
    Serial.println("Error initializing ESP-NOW");
    return;
  }

  esp_now_register_send_cb(OnDataSent);

  // Register peer


  memcpy(peerInfo.peer_addr, broadcastAddress, 6);
  peerInfo.channel = 0;
  peerInfo.encrypt = false;

  // Add peer
  if (esp_now_add_peer(&peerInfo) != ESP_OK) {
    Serial.println("Failed to add peer");
    return;
  }
  // Register for a callback function that will be called when data is received
  esp_now_register_recv_cb(OnDataRecv);
}

// loop. You can use "if (WLED_CONNECTED)" to check for successful connection
void userLoop()
{
if (millis() - lastInputRead > inputReadInterval)
  {
    // check if bypass switch is on
    autoStopEnabled = digitalRead(bypassSwitchPin);
    setLED(autoStop, autoStopEnabled);

    // check if cow forward safety sensor is triggered
    cowFWDSaftey = digitalRead(cowFWDsafetySensorPin);
    setLED(cowFWD, cowFWDSaftey);
    setRelay(water, cowFWD);
  }

  if (stallChange)
  {
    if (!speedMeasured)
    {
      getMedianSpeed();
    }

    if (millis() > (lastStallChange + timeToStallCenterPos))
    {
      stallEmpty = digitalRead(stallSensorPin);
      if (stallEmpty)
      {
        setLED(emptyStall, 1);
        if (autoStopEnabled)
        {
          setRelay(parlor, 1);
        }
        else
        {
          setRelay(parlor, 0);
        }
      }
      else
      {
        setLED(emptyStall, 0);
        setRelay(parlor, 0);
      }
      stallChange = 0;
    }
  }

  if (sendTime.update())  //Checks to see if set time has past
  {

    // Set values to send
    strcpy(myDataOut.a, "THIS IS A CHAR");
    myDataOut.b = random(1, 20);
    myDataOut.c = 1.2;
    if (myDataOut.d == false) myDataOut.d = true;
    else myDataOut.d = false;

    // Send message via ESP-NOW
    esp_err_t result = esp_now_send(broadcastAddress, (uint8_t *)&myDataOut, sizeof(myDataOut));


    if (result == ESP_OK) {
      Serial.println("Sent with success");
    } else {
      Serial.println("Error sending the data");
    }
  }
}
